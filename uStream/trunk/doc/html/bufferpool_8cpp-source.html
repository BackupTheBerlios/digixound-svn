<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>uStream: C:/ustream_streaming_architecture/uOsUtil/src/core/bufferpool.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a></div>
<div class="nav">
<a class="el" href="dir_000000.html">ustream_streaming_architecture</a>&nbsp;/&nbsp;<a class="el" href="dir_000001.html">uOsUtil</a>&nbsp;/&nbsp;<a class="el" href="dir_000006.html">src</a>&nbsp;/&nbsp;<a class="el" href="dir_000007.html">core</a></div>
<h1>bufferpool.cpp</h1><a href="bufferpool_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment">  uSTREAM LIGHT-WEIGHT STREAMING ARCHITECTURE</span>
00003 <span class="comment">  Copyright (C) 2005 Luis Serrano (luis@kontrol-dj.com) </span>
00004 <span class="comment">  </span>
00005 <span class="comment">  Based on DANUBIO STREAMING ARCHITECTURE by Michele Iacobellis (m.iacobellis@nexotech.it)</span>
00006 <span class="comment"></span>
00007 <span class="comment">  This program is free software; you can redistribute it and/or modify</span>
00008 <span class="comment">  it under the terms of the GNU General Public License as published by</span>
00009 <span class="comment">  the Free Software Foundation; either version 2 of the License, or</span>
00010 <span class="comment">  (at your option) any later version.</span>
00011 <span class="comment">  </span>
00012 <span class="comment">  This program is distributed in the hope that it will be useful,</span>
00013 <span class="comment">  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00014 <span class="comment">  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
00015 <span class="comment">  GNU General Public License for more details.</span>
00016 <span class="comment">  </span>
00017 <span class="comment">  You should have received a copy of the GNU General Public License</span>
00018 <span class="comment">  along with this program; if not, write to the Free Software</span>
00019 <span class="comment">  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
00020 <span class="comment">*/</span>
00021 
00022 <span class="preprocessor">#include "<a class="code" href="bufferpool_8hpp.html">bufferpool.hpp</a>"</span>
00023 <span class="preprocessor">#include "<a class="code" href="thread_8hpp.html">thread.hpp</a>"</span>
00024 
00025 <span class="keyword">namespace </span>uStreamLib {
<a name="l00026"></a><a class="code" href="classu_stream_lib_1_1_buffer_pool.html#a0">00026</a>         BufferPool::BufferPool(<span class="keywordtype">void</span>)
00027                 : <a class="code" href="classu_stream_lib_1_1_object.html">Object</a>(<a class="code" href="namespaceu_stream_lib.html#a262a147">UOSUTIL_RTTI_BUFFER_POOL</a>), _bufs(NULL), _bcount(0)
00028         {
00029                 <span class="comment">// nothing to do</span>
00030         }
00031 
<a name="l00032"></a><a class="code" href="classu_stream_lib_1_1_buffer_pool.html#a1">00032</a>         BufferPool::~BufferPool(<span class="keywordtype">void</span>)
00033         {
00034                 <a class="code" href="namespaceu_stream_lib.html#a243">uint32</a> bid = 0, i = 0;
00035                 <a class="code" href="namespaceu_stream_lib.html#a243">uint32</a> wait = 10, bc = 0;
00036 
00037                 <a class="code" href="classu_stream_lib_1_1_mutex_locker.html">MutexLocker</a> ml(&amp;_mutexReset);
00038 
00039                 <span class="comment">/*</span>
00040 <span class="comment">                 * Here we must free the unlocked buffers first,</span>
00041 <span class="comment">                 * then wait some time for further buffers that will</span>
00042 <span class="comment">                 * be freed by worker threads.</span>
00043 <span class="comment">                 */</span>
00044                 <span class="keywordflow">while</span> (bc &lt; _bcount &amp;&amp; i++ &lt; wait) {
00045                         <a class="code" href="classu_stream_lib_1_1_data_buf.html">DataBuf</a>* buf = (<a class="code" href="classu_stream_lib_1_1_data_buf.html">DataBuf</a>*) _psFree.<a class="code" href="classu_stream_lib_1_1_p_stack.html#a7">pop</a>();
00046                         <span class="keywordflow">if</span> (buf) {
00047                                 <span class="comment">// get buffer id</span>
00048                                 bid = buf-&gt;<a class="code" href="classu_stream_lib_1_1_data_buf.html#a8">getBID</a>();
00049 
00050                                 <span class="comment">// free selected buffer</span>
00051                                 <span class="keyword">delete</span> _bufs[bid];
00052 
00053                                 <span class="comment">// reset pointer</span>
00054                                 _bufs[bid] = NULL;
00055 
00056                                 <span class="comment">// count freed buffers</span>
00057                                 bc++;
00058                         } <span class="keywordflow">else</span> {
00059                                 <span class="comment">// wait some time</span>
00060                                 Thread::sleep(50);
00061                         }
00062                 }
00063 
00064                 <span class="comment">/*</span>
00065 <span class="comment">                 * Timeout expired, so check which buffers are not</span>
00066 <span class="comment">                 * returned home.</span>
00067 <span class="comment">                 */</span>
00068                 <span class="keywordflow">for</span> (i = 0; i &lt; _bcount; i++) {
00069                         <span class="keywordflow">if</span> (_bufs[i]) {
00070                                 <span class="comment">// DEBUG</span>
00071                                 <a class="code" href="typedefs_8hpp.html#a14">UOSUTIL_DOUT</a>((<span class="stringliteral">"BufferPool: Buffer %d is NOT NULL\n"</span>, i));
00072                                 <span class="keywordflow">if</span> (!_bufs[i]-&gt;<a class="code" href="classu_stream_lib_1_1_data_buf.html#a6">isInUse</a>()) {
00073                                         <span class="comment">// DEBUG</span>
00074                                         <a class="code" href="typedefs_8hpp.html#a14">UOSUTIL_DOUT</a>((<span class="stringliteral">"BufferPool: Buffer %d is NOT IN USE\n"</span>, i));
00075                                         <a class="code" href="typedefs_8hpp.html#a14">UOSUTIL_DOUT</a>((<span class="stringliteral">"BufferPool: Buffer %d will be DELETED\n"</span>, i));
00076                                         <span class="keyword">delete</span> _bufs[i];
00077                                 } <span class="keywordflow">else</span> {
00078                                         <span class="comment">// DEBUG</span>
00079                                         <a class="code" href="typedefs_8hpp.html#a14">UOSUTIL_DOUT</a>((<span class="stringliteral">"BufferPool: Buffer %d is IN USE: leaked\n"</span>, i));
00080                                 }
00081                         } <span class="keywordflow">else</span> {
00082                                 <span class="comment">// DEBUG</span>
00083                                 <a class="code" href="typedefs_8hpp.html#a14">UOSUTIL_DOUT</a>((<span class="stringliteral">"BufferPool: Buffer %d is NULL, ignored\n"</span>, i));
00084                         }
00085                 }
00086 
00087                 <span class="comment">/*</span>
00088 <span class="comment">                 * Delete other objects.</span>
00089 <span class="comment">                 */</span>
00090 
00091                 <span class="keyword">delete</span>[] _bufs;
00092         }
00093 
<a name="l00094"></a><a class="code" href="classu_stream_lib_1_1_buffer_pool.html#a2">00094</a>         <a class="code" href="namespaceu_stream_lib.html#a244">int32</a> BufferPool::init(<span class="keywordtype">char</span>* name, uint32 bsize, uint32 bcount,
00095                 uint32 limit)
00096         {
00097                 <a class="code" href="namespaceu_stream_lib.html#a244">int32</a> ret = 0;
00098 
00099                 <span class="comment">// do some checks</span>
00100                 <span class="keywordflow">if</span> (!bsize)
00101                         bsize = 1;
00102                 <span class="keywordflow">if</span> (!bcount)
00103                         bcount = 1;
00104 
00105                 <span class="comment">// initialize buffers count</span>
00106                 _bcount = bcount;
00107 
00108                 <span class="comment">// initialize buffer pool's name buffer</span>
00109                 ret = _dbName.<a class="code" href="classu_stream_lib_1_1_data_buf.html#a2">init</a>(name);
00110                 <span class="keywordflow">if</span> (ret == FAILURE)
00111                         <span class="keywordflow">return</span> FAILURE;
00112 
00113                 <span class="comment">// create buffers array</span>
00114                 _bufs = <span class="keyword">new</span> <a class="code" href="classu_stream_lib_1_1_data_buf.html">DataBuf</a> * [bcount];
00115                 <span class="keywordflow">if</span> (!_bufs)
00116                         <span class="keywordflow">return</span> FAILURE;
00117 
00118                 <span class="comment">// initialize buffer ids stack</span>
00119                 ret = _psFree.<a class="code" href="classu_stream_lib_1_1_p_stack.html#a2">init</a>(bcount);
00120                 <span class="keywordflow">if</span> (ret == FAILURE)
00121                         <span class="keywordflow">return</span> FAILURE;
00122 
00123                 <span class="comment">// initialize semaphores</span>
00124                 ret = _semFree.<a class="code" href="classu_stream_lib_1_1_semaphore.html#a2">init</a>(bcount);
00125                 <span class="keywordflow">if</span> (ret == FAILURE)
00126                         <span class="keywordflow">return</span> FAILURE;
00127 
00128                 ret = _semUsed.<a class="code" href="classu_stream_lib_1_1_semaphore.html#a2">init</a>(0);
00129                 <span class="keywordflow">if</span> (ret == FAILURE)
00130                         <span class="keywordflow">return</span> FAILURE;
00131 
00132                 <span class="comment">// initialize mutex for reset</span>
00133                 ret = _mutexReset.<a class="code" href="classu_stream_lib_1_1_mutex.html#a2">init</a>();
00134                 <span class="keywordflow">if</span> (ret == FAILURE)
00135                         <span class="keywordflow">return</span> FAILURE;
00136 
00137                 <span class="comment">// allocate each buffer</span>
00138                 <span class="keywordflow">for</span> (<a class="code" href="namespaceu_stream_lib.html#a243">uint32</a> i = 0; i &lt; bcount; i++) {
00139                         <span class="comment">// create databuf</span>
00140                         _bufs[i] = <span class="keyword">new</span> <a class="code" href="classu_stream_lib_1_1_data_buf.html">DataBuf</a>();
00141 
00142                         <span class="comment">// initialize databuf</span>
00143                         ret = _bufs[i]-&gt;<a class="code" href="classu_stream_lib_1_1_data_buf.html#a2">init</a>(bsize, i, limit, DataBuf::ALLOC_ONUSE, <span class="keyword">this</span>);
00144                         <span class="keywordflow">if</span> (ret == FAILURE)
00145                                 <span class="keywordflow">return</span> FAILURE;
00146 
00147                         <span class="comment">// push buffer pointer into the "free buffers" stack</span>
00148                         _psFree.<a class="code" href="classu_stream_lib_1_1_p_stack.html#a6">push</a>(_bufs[i]);
00149                 }
00150 
00151                 <span class="comment">// ok</span>
00152                 <a class="code" href="classu_stream_lib_1_1_object.html#b0">setOk</a>(<span class="keyword">true</span>);
00153                 <span class="keywordflow">return</span> SUCCESS;
00154         }
00155 
<a name="l00156"></a><a class="code" href="classu_stream_lib_1_1_buffer_pool.html#a3">00156</a>         <a class="code" href="namespaceu_stream_lib.html#a244">int32</a> BufferPool::resize(uint32 bsize, uint32 bcount)
00157         {
00158                 <span class="comment">// lock mutex for reset</span>
00159                 <a class="code" href="classu_stream_lib_1_1_mutex_locker.html">MutexLocker</a> ml(&amp;_mutexReset);
00160 
00161                 <span class="comment">// output</span>
00162                 fprintf(stderr, <span class="stringliteral">"BufferPool::resize(%u,%u)"</span>, bsize, bcount);
00163 
00164                 <span class="comment">// resize is not implemented</span>
00165                 <span class="keywordflow">return</span> FAILURE;
00166         }
00167 
<a name="l00168"></a><a class="code" href="classu_stream_lib_1_1_buffer_pool.html#a4">00168</a>         <a class="code" href="namespaceu_stream_lib.html#a243">uint32</a> BufferPool::getBuffer(<span class="keywordtype">void</span>)
00169         {
00170                 <a class="code" href="classu_stream_lib_1_1_data_buf.html">DataBuf</a>* buf = NULL;
00171 
00172                 <span class="comment">// lock mutex for reset</span>
00173                 <a class="code" href="classu_stream_lib_1_1_mutex_locker.html">MutexLocker</a> ml(&amp;_mutexReset);
00174 
00175                 <span class="comment">// decrement free buffers counter</span>
00176                 _semFree.<a class="code" href="classu_stream_lib_1_1_semaphore.html#a3">wait</a>();
00177 
00178                 <span class="comment">// get bid from stack</span>
00179                 buf = (<a class="code" href="classu_stream_lib_1_1_data_buf.html">DataBuf</a> *) _psFree.<a class="code" href="classu_stream_lib_1_1_p_stack.html#a7">pop</a>();
00180 
00181                 <span class="comment">// check if there are no more free buffers</span>
00182                 <span class="keywordflow">if</span> (!buf) {
00183                         fprintf(stderr, <span class="stringliteral">"BufferPool: NO MORE FREE BUFFERS...\n"</span>);
00184                         <span class="keywordflow">return</span> 0;
00185                 }
00186 
00187                 <span class="comment">// increment used buffers counter</span>
00188                 _semUsed.<a class="code" href="classu_stream_lib_1_1_semaphore.html#a5">post</a>();
00189 
00190                 <span class="comment">// return this bid</span>
00191                 <span class="keywordflow">return</span> buf-&gt;<a class="code" href="classu_stream_lib_1_1_data_buf.html#a8">getBID</a>();
00192         }
00193 
<a name="l00194"></a><a class="code" href="classu_stream_lib_1_1_buffer_pool.html#a5">00194</a>         <a class="code" href="namespaceu_stream_lib.html#a244">int32</a> BufferPool::tryGetBuffer(uint32* bid)
00195         {
00196                 <a class="code" href="namespaceu_stream_lib.html#a244">int32</a> ret = 0;
00197 
00198                 <span class="comment">// lock mutex for reset</span>
00199                 <a class="code" href="classu_stream_lib_1_1_mutex_locker.html">MutexLocker</a> ml(&amp;_mutexReset);
00200 
00201                 <span class="comment">// decrement free buffers counter</span>
00202                 ret = _semFree.<a class="code" href="classu_stream_lib_1_1_semaphore.html#a4">tryWait</a>();
00203                 <span class="keywordflow">if</span> (ret == FAILURE)
00204                         <span class="keywordflow">return</span> FAILURE;
00205 
00206                 <a class="code" href="classu_stream_lib_1_1_data_buf.html">DataBuf</a>* buf = (<a class="code" href="classu_stream_lib_1_1_data_buf.html">DataBuf</a>*) _psFree.<a class="code" href="classu_stream_lib_1_1_p_stack.html#a7">pop</a>();
00207                 <span class="keywordflow">if</span> (!buf) {
00208                         puts(<span class="stringliteral">"Critical: null buffer in pool"</span>); <span class="keywordflow">return</span> FAILURE;
00209                 }
00210 
00211                 *bid = buf-&gt;<a class="code" href="classu_stream_lib_1_1_data_buf.html#a8">getBID</a>();
00212 
00213                 <span class="comment">// increment used buffers counter</span>
00214                 _semUsed.<a class="code" href="classu_stream_lib_1_1_semaphore.html#a5">post</a>();
00215 
00216                 <span class="comment">// ok</span>
00217                 <span class="keywordflow">return</span> SUCCESS;
00218         }
00219 
<a name="l00220"></a><a class="code" href="classu_stream_lib_1_1_buffer_pool.html#a6">00220</a>         <span class="keywordtype">void</span> BufferPool::freeBuffer(uint32 bid)
00221         {
00222                 <a class="code" href="namespaceu_stream_lib.html#a244">int32</a> ret = 0;
00223 
00224                 <span class="comment">// lock mutex for reset</span>
00225                 <a class="code" href="classu_stream_lib_1_1_mutex_locker.html">MutexLocker</a> ml(&amp;_mutexReset);
00226 
00227                 <span class="keywordflow">if</span> (bid &lt; _bcount) {
00228                         <span class="comment">// decrement used buffers counter</span>
00229                         _semUsed.<a class="code" href="classu_stream_lib_1_1_semaphore.html#a3">wait</a>();
00230 
00231                         _bufs[bid]-&gt;<a class="code" href="classu_stream_lib_1_1_data_buf.html#a16">setCount</a>(0);
00232                         _bufs[bid]-&gt;<a class="code" href="classu_stream_lib_1_1_data_buf.html#a7">setInUse</a>(<span class="keyword">false</span>);
00233 
00234                         ret = _psFree.<a class="code" href="classu_stream_lib_1_1_p_stack.html#a6">push</a>(_bufs[bid]);
00235                         <span class="keywordflow">if</span> (ret == FAILURE) {
00236                                 fprintf(stderr, <span class="stringliteral">"BufferPool: STACK IS FULL.\n"</span>);
00237                         }
00238 
00239                         <span class="comment">// increment free buffers counter</span>
00240                         _semFree.<a class="code" href="classu_stream_lib_1_1_semaphore.html#a5">post</a>();
00241                 }
00242         }
00243 
<a name="l00244"></a><a class="code" href="classu_stream_lib_1_1_buffer_pool.html#a7">00244</a>         <a class="code" href="classu_stream_lib_1_1_data_buf.html">DataBuf</a>* BufferPool::use(uint32 bid)
00245         {
00246                 <a class="code" href="classu_stream_lib_1_1_data_buf.html">DataBuf</a>* buf = NULL;
00247 
00248                 <span class="comment">// lock mutex for reset</span>
00249                 <a class="code" href="classu_stream_lib_1_1_mutex_locker.html">MutexLocker</a> ml(&amp;_mutexReset);
00250 
00251                 <span class="keywordflow">if</span> (bid &lt; _bcount) {
00252                         buf = _bufs[bid];
00253                         buf-&gt;<a class="code" href="classu_stream_lib_1_1_data_buf.html#a7">setInUse</a>(<span class="keyword">true</span>);
00254                 }
00255 
00256                 <span class="comment">// ok</span>
00257                 <span class="keywordflow">return</span> buf;
00258         }
00259 
<a name="l00260"></a><a class="code" href="classu_stream_lib_1_1_buffer_pool.html#a8">00260</a>         <a class="code" href="namespaceu_stream_lib.html#a244">int32</a> BufferPool::getBuffersCount(<span class="keywordtype">void</span>)
00261         {
00262                 <span class="comment">// lock mutex for reset</span>
00263                 <a class="code" href="classu_stream_lib_1_1_mutex_locker.html">MutexLocker</a> ml(&amp;_mutexReset);
00264                 <span class="keywordflow">return</span> _bcount;
00265         }
00266 
<a name="l00267"></a><a class="code" href="classu_stream_lib_1_1_buffer_pool.html#a9">00267</a>         <a class="code" href="namespaceu_stream_lib.html#a244">int32</a> BufferPool::getFreeBuffersCount(<span class="keywordtype">void</span>)
00268         {
00269                 <span class="comment">// lock mutex for reset</span>
00270                 <a class="code" href="classu_stream_lib_1_1_mutex_locker.html">MutexLocker</a> ml(&amp;_mutexReset);
00271                 <span class="keywordflow">return</span> _psFree.<a class="code" href="classu_stream_lib_1_1_p_stack.html#a4">getStackPointer</a>();
00272         }
00273 
<a name="l00274"></a><a class="code" href="classu_stream_lib_1_1_buffer_pool.html#a10">00274</a>         <a class="code" href="namespaceu_stream_lib.html#a243">uint32</a> BufferPool::getBufferSize(uint32 bid)
00275         {
00276                 <a class="code" href="namespaceu_stream_lib.html#a243">uint32</a> ret = 0;
00277 
00278                 <span class="comment">// lock mutex for reset</span>
00279                 <a class="code" href="classu_stream_lib_1_1_mutex_locker.html">MutexLocker</a> ml(&amp;_mutexReset);
00280 
00281                 <span class="keywordflow">if</span> (bid &lt; _bcount)
00282                         ret = _bufs[bid]-&gt;<a class="code" href="classu_stream_lib_1_1_data_buf.html#a10">getSize</a>();
00283 
00284                 <span class="comment">// ok</span>
00285                 <span class="keywordflow">return</span> ret;
00286         }
00287 
<a name="l00288"></a><a class="code" href="classu_stream_lib_1_1_buffer_pool.html#a11">00288</a>         <span class="keywordtype">void</span> BufferPool::reset(<span class="keywordtype">void</span>)
00289         {
00290                 <a class="code" href="classu_stream_lib_1_1_data_buf.html">DataBuf</a>* buf = NULL;
00291                 <a class="code" href="namespaceu_stream_lib.html#a244">int32</a> ret = 0;
00292 
00293                 <span class="comment">// lock mutex for reset</span>
00294                 <a class="code" href="classu_stream_lib_1_1_mutex_locker.html">MutexLocker</a> ml(&amp;_mutexReset);
00295 
00296                 <span class="comment">// empty buffers stack</span>
00297                 <span class="keywordflow">for</span> (<a class="code" href="namespaceu_stream_lib.html#a243">uint32</a> j = 0; j &lt; _bcount; j++) {
00298                         buf = (<a class="code" href="classu_stream_lib_1_1_data_buf.html">DataBuf</a> *) _psFree.<a class="code" href="classu_stream_lib_1_1_p_stack.html#a7">pop</a>();
00299                         <span class="keywordflow">if</span> (!buf)
00300                                 <span class="keywordflow">break</span>;
00301 
00302                         <a class="code" href="typedefs_8hpp.html#a14">UOSUTIL_DOUT</a>((<span class="stringliteral">"Get buffer from the stack: %u\n"</span>, buf-&gt;<a class="code" href="classu_stream_lib_1_1_data_buf.html#a8">getBID</a>()));
00303                 }
00304 
00305                 <span class="comment">// reset "used" semaphore</span>
00306                 <span class="keywordflow">while</span> ((ret = _semUsed.<a class="code" href="classu_stream_lib_1_1_semaphore.html#a4">tryWait</a>()) != FAILURE)
00307                         <a class="code" href="typedefs_8hpp.html#a14">UOSUTIL_DOUT</a>((<span class="stringliteral">"Waiting on semaphore \"used\"\n"</span>));
00308 
00309                 <span class="comment">// reset "free" semaphore    </span>
00310                 <span class="keywordflow">while</span> ((ret = _semFree.<a class="code" href="classu_stream_lib_1_1_semaphore.html#a4">tryWait</a>()) != FAILURE)
00311                         <a class="code" href="typedefs_8hpp.html#a14">UOSUTIL_DOUT</a>((<span class="stringliteral">"Waiting on semaphore \"free\"\n"</span>));
00312 
00313                 <span class="comment">// put all buffers in the buffers stack</span>
00314                 <span class="keywordflow">for</span> (<a class="code" href="namespaceu_stream_lib.html#a243">uint32</a> i = 0; i &lt; _bcount; i++) {
00315                         <span class="comment">// reset buffer</span>
00316                         _bufs[i]-&gt;<a class="code" href="classu_stream_lib_1_1_data_buf.html#a7">setInUse</a>(<span class="keyword">false</span>);
00317                         _bufs[i]-&gt;<a class="code" href="classu_stream_lib_1_1_data_buf.html#a16">setCount</a>(0);
00318 
00319                         <span class="comment">// push buffer pointer into the "free buffers" stack</span>
00320                         _psFree.<a class="code" href="classu_stream_lib_1_1_p_stack.html#a6">push</a>(_bufs[i]);
00321 
00322                         <span class="comment">// DEBUG</span>
00323                         <a class="code" href="typedefs_8hpp.html#a14">UOSUTIL_DOUT</a>((<span class="stringliteral">"Buffer %u pushed.\n"</span>, _bufs[i]-&gt;getBID()));
00324                 }
00325 
00326                 <span class="comment">// reset "free" semaphore    </span>
00327                 <span class="keywordflow">for</span> (<a class="code" href="namespaceu_stream_lib.html#a243">uint32</a> k = 0; k &lt; _bcount; k++) {
00328                         <a class="code" href="typedefs_8hpp.html#a14">UOSUTIL_DOUT</a>((<span class="stringliteral">"Posting semaphore \"free\" (%u)\n"</span>, k));
00329                         _semFree.<a class="code" href="classu_stream_lib_1_1_semaphore.html#a5">post</a>();
00330                 }
00331         }
00332 }
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Thu Feb 9 19:03:30 2006 for uStream by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
