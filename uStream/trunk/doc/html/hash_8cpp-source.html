<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>uStream: C:/ustream_streaming_architecture/uOsUtil/src/core/hash.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a></div>
<div class="nav">
<a class="el" href="dir_000000.html">ustream_streaming_architecture</a>&nbsp;/&nbsp;<a class="el" href="dir_000001.html">uOsUtil</a>&nbsp;/&nbsp;<a class="el" href="dir_000006.html">src</a>&nbsp;/&nbsp;<a class="el" href="dir_000007.html">core</a></div>
<h1>hash.cpp</h1><a href="hash_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment">  uSTREAM LIGHT-WEIGHT STREAMING ARCHITECTURE</span>
00003 <span class="comment">  Copyright (C) 2005 Luis Serrano (luis@kontrol-dj.com) </span>
00004 <span class="comment">  </span>
00005 <span class="comment">  Based on DANUBIO STREAMING ARCHITECTURE by Michele Iacobellis (m.iacobellis@nexotech.it)</span>
00006 <span class="comment">  </span>
00007 <span class="comment">  This program is free software; you can redistribute it and/or modify</span>
00008 <span class="comment">  it under the terms of the GNU General Public License as published by</span>
00009 <span class="comment">  the Free Software Foundation; either version 2 of the License, or</span>
00010 <span class="comment">  (at your option) any later version.</span>
00011 <span class="comment">  </span>
00012 <span class="comment">  This program is distributed in the hope that it will be useful,</span>
00013 <span class="comment">  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00014 <span class="comment">  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
00015 <span class="comment">  GNU General Public License for more details.</span>
00016 <span class="comment">  </span>
00017 <span class="comment">  You should have received a copy of the GNU General Public License</span>
00018 <span class="comment">  along with this program; if not, write to the Free Software</span>
00019 <span class="comment">  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
00020 <span class="comment">  </span>
00021 <span class="comment">*/</span>
00022 
00023 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00024 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00025 <span class="preprocessor">#include &lt;string.h&gt;</span>
00026 
00027 <span class="preprocessor">#include "<a class="code" href="hash_8hpp.html">hash.hpp</a>"</span>
00028 <span class="preprocessor">#include "<a class="code" href="utils_8hpp.html">utils.hpp</a>"</span>
00029 <span class="preprocessor">#include "<a class="code" href="memory_8hpp.html">memory.hpp</a>"</span>
00030 
00031 <span class="keyword">namespace </span>uStreamLib {
<a name="l00032"></a><a class="code" href="classu_stream_lib_1_1_hash.html#a0">00032</a>         Hash::Hash(<span class="keywordtype">void</span>)
00033                 : <a class="code" href="classu_stream_lib_1_1_object.html">Object</a>(<a class="code" href="namespaceu_stream_lib.html#a262a169">UOSUTIL_RTTI_HASH</a>), _hte(NULL), _size(0), _elem_count(0),
00034                 _bytes(0)
00035         {
00036                 <span class="comment">// nothing to do</span>
00037         }
00038 
<a name="l00039"></a><a class="code" href="classu_stream_lib_1_1_hash.html#a1">00039</a>         Hash::~Hash(<span class="keywordtype">void</span>)
00040         {
00041                 <span class="keyword">struct </span>hash_elem_t* cur = NULL;
00042                 <span class="keyword">struct </span>hash_elem_t* base = NULL;
00043                 <span class="keyword">struct </span>hash_elem_t* next = NULL;
00044                 <a class="code" href="namespaceu_stream_lib.html#a243">uint32</a> i = 0;
00045 
00046                 <span class="keywordflow">for</span> (i = 0; i &lt; _size; i++) {
00047                         <span class="comment">// get a base slot</span>
00048                         base = &amp;(_hte[i]);
00049                         cur = base-&gt;next;
00050 
00051                         <span class="comment">// scan its chain</span>
00052                         <span class="keywordflow">while</span> (cur) {
00053                                 <span class="comment">// store next element</span>
00054                                 next = cur-&gt;next;
00055 
00056                                 <span class="comment">// remove current element</span>
00057                                 <span class="keywordflow">if</span> (!cur-&gt;empty)
00058                                         _htefree(cur);
00059 
00060                                 free(cur);
00061                                 _bytes -= <span class="keyword">sizeof</span>(<span class="keyword">struct </span>hash_elem_t);
00062 
00063                                 <span class="comment">// update cursor</span>
00064                                 cur = next;
00065                         }
00066 
00067                         <span class="keywordflow">if</span> (!base-&gt;empty)
00068                                 _htefree(base);
00069                 }
00070 
00071                 <span class="keywordflow">if</span> (_hte)
00072                         free(_hte);
00073         }
00074 
<a name="l00075"></a><a class="code" href="classu_stream_lib_1_1_hash.html#a2">00075</a>         <a class="code" href="namespaceu_stream_lib.html#a244">int32</a> Hash::init(uint32 size)
00076         {
00077                 <a class="code" href="namespaceu_stream_lib.html#a243">uint32</a> i, chain_depth = 8;
00078                 <a class="code" href="namespaceu_stream_lib.html#a244">int32</a> ret = 0;
00079 
00080                 ret = _dbErrorString.<a class="code" href="classu_stream_lib_1_1_data_buf.html#a2">init</a>(16);
00081                 <span class="keywordflow">if</span> (ret == FAILURE)
00082                         <span class="keywordflow">return</span> FAILURE;
00083 
00084                 _hte = (<span class="keyword">struct </span>hash_elem_t *)
00085                         malloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> hash_elem_t) * size);
00086                 <span class="keywordflow">if</span> (!_hte)
00087                         <span class="keywordflow">return</span> FAILURE;
00088 
00089                 <span class="comment">// DEBUG</span>
00090                 <a class="code" href="typedefs_8hpp.html#a14">UOSUTIL_DOUT</a>((<span class="stringliteral">"Hash(): init(%u)\n"</span>, size));
00091 
00092                 _size = size;
00093                 _elem_count = 0;
00094                 _bytes = 0;
00095 
00096                 ret = _enKeys.<a class="code" href="classu_stream_lib_1_1_enumeration.html#a2">init</a>(size * chain_depth);
00097                 <span class="keywordflow">if</span> (ret == FAILURE)
00098                         <span class="keywordflow">return</span> FAILURE;
00099 
00100                 ret = _enValues.<a class="code" href="classu_stream_lib_1_1_enumeration.html#a2">init</a>(size * chain_depth);
00101                 <span class="keywordflow">if</span> (ret == FAILURE)
00102                         <span class="keywordflow">return</span> FAILURE;
00103 
00104                 <span class="keywordflow">for</span> (i = 0; i &lt; _size; i++) {
00105                         _hte[i].empty = <span class="keyword">true</span>;
00106                         _hte[i].key = NULL;
00107                         _hte[i].key_size = 0;
00108                         _hte[i].value = NULL;
00109                         _hte[i].pvalue = NULL;
00110                         _hte[i].value_size = 0;
00111                         _hte[i].next = NULL;
00112                         _hte[i].hit_count = 0;
00113                 }
00114 
00115                 <a class="code" href="classu_stream_lib_1_1_object.html#b0">setOk</a>(<span class="keyword">true</span>);
00116                 <span class="keywordflow">return</span> SUCCESS;
00117         }
00118 
<a name="l00119"></a><a class="code" href="classu_stream_lib_1_1_hash.html#a3">00119</a>         <a class="code" href="namespaceu_stream_lib.html#a243">uint32</a> Hash::hashCode(<span class="keywordtype">char</span>* key, uint32 key_size, uint32 hash_size)
00120         {
00121                 <a class="code" href="namespaceu_stream_lib.html#a243">uint32</a> code = 0, g = 0;
00122                 <span class="keywordtype">char</span>* ptr = key;
00123 
00124                 <span class="keywordflow">if</span> (!hash_size)
00125                         <span class="keywordflow">return</span> 0;
00126 
00127                 <span class="keywordflow">for</span> (<a class="code" href="namespaceu_stream_lib.html#a243">uint32</a> i = 0; i &lt; key_size; i++, ptr++) {
00128                         code = (code &lt;&lt; 4) + *ptr;
00129                         <span class="keywordflow">if</span> ((g = code &amp; 0xf0000000)) {
00130                                 code ^= (g &gt;&gt; 24);
00131                                 code ^= g;
00132                         }
00133                 }
00134 
00135                 <span class="keywordflow">return</span> (code % hash_size);
00136         }
00137 
<a name="l00138"></a><a class="code" href="classu_stream_lib_1_1_hash.html#a4">00138</a>         <a class="code" href="namespaceu_stream_lib.html#a244">int32</a> Hash::compare(<span class="keywordtype">char</span>* a, <span class="keywordtype">char</span>* b, uint32 a_b_size)
00139         {
00140                 <span class="keywordflow">return</span> memcmp(a, b, a_b_size);
00141         }
00142 
<a name="l00143"></a><a class="code" href="classu_stream_lib_1_1_hash.html#a12">00143</a>         <a class="code" href="namespaceu_stream_lib.html#a244">int32</a> Hash::put(<span class="keywordtype">char</span>* key, uint32 keysz, <span class="keywordtype">char</span>* val, uint32 valsz,
00144                 <span class="keywordtype">bool</span> replace)
00145         {
00146                 <span class="keyword">struct </span>hash_elem_t* cur = NULL;
00147                 <span class="keyword">struct </span>hash_elem_t* pre = NULL;
00148                 <a class="code" href="namespaceu_stream_lib.html#a243">uint32</a> code = 0, do_replace = 0;
00149 
00150                 <span class="comment">/* compute hash code */</span>
00151                 <span class="keywordflow">if</span> (!_size)
00152                         <span class="keywordflow">return</span> FAILURE;
00153                 code = <a class="code" href="classu_stream_lib_1_1_hash.html#a3">hashCode</a>(key, keysz, _size);
00154 
00155                 <span class="comment">/* no collision detected */</span>
00156                 <span class="keywordflow">if</span> (_hte[code].empty) {
00157                         _hte[code].key = (<span class="keywordtype">char</span> *) malloc(keysz);
00158                         <span class="keywordflow">if</span> (!_hte[code].key)
00159                                 <span class="keywordflow">return</span> FAILURE;
00160 
00161                         Memory::memCopy(_hte[code].key, key, keysz);
00162                         _hte[code].key_size = keysz;
00163                         _bytes += keysz;
00164 
00165                         _hte[code].value = (<span class="keywordtype">char</span> *) malloc(valsz);
00166                         <span class="keywordflow">if</span> (!_hte[code].value) {
00167                                 free(_hte[code].key);
00168                                 <span class="keywordflow">return</span> FAILURE;
00169                         }
00170 
00171                         Memory::memCopy(_hte[code].value, val, valsz);
00172                         _hte[code].value_size = valsz;
00173                         _hte[code].empty = <span class="keyword">false</span>;
00174                         _elem_count++;
00175                         _bytes += valsz;
00176 
00177                         <span class="keywordflow">return</span> SUCCESS;
00178                 }
00179 
00180                 <span class="comment">/* collision detected */</span>
00181                 cur = &amp;_hte[code];
00182 
00183                 <span class="comment">/* get statistics on collisions */</span>
00184                 <span class="keywordflow">if</span> (!replace)
00185                         cur-&gt;hit_count += 1;
00186 
00187                 <span class="comment">/* chain scanning */</span>
00188                 <span class="keywordflow">while</span> (!cur-&gt;empty) {
00189                         <span class="comment">/* check for key duplicates */</span>
00190                         <span class="keywordflow">if</span> (cur-&gt;key_size == keysz) {
00191                                 <span class="keywordflow">if</span> (!<a class="code" href="classu_stream_lib_1_1_hash.html#a4">compare</a>(cur-&gt;key, key, keysz)) {
00192                                         <span class="keywordflow">if</span> (replace) {
00193                                                 do_replace = 1; <span class="keywordflow">break</span>;
00194                                         } <span class="keywordflow">else</span>
00195                                                 <span class="keywordflow">return</span> KEY_EXISTS;
00196                                 }
00197                         }
00198 
00199                         <span class="comment">// DEBUG</span>
00200                         <a class="code" href="typedefs_8hpp.html#a14">UOSUTIL_DOUT</a>((<span class="stringliteral">"Hash::put(%s [%u]): collision, code = %u, hit = %u\n"</span>,
00201                                 key, keysz, code, cur-&gt;hit_count));
00202 
00203                         <span class="comment">/* update pointers */</span>
00204                         pre = cur;
00205                         cur = cur-&gt;next;
00206 
00207                         <span class="keywordflow">if</span> (cur == NULL) {
00208                                 cur = (<span class="keyword">struct </span>hash_elem_t *)
00209                                         malloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> hash_elem_t));
00210                                 <span class="keywordflow">if</span> (!cur)
00211                                         <span class="keywordflow">return</span> FAILURE;
00212 
00213                                 memset(cur, 0, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> hash_elem_t));
00214                                 _bytes += <span class="keyword">sizeof</span>(<span class="keyword">struct </span>hash_elem_t);
00215 
00216                                 cur-&gt;empty = <span class="keyword">true</span>;
00217                                 pre-&gt;next = cur;
00218 
00219                                 <span class="keywordflow">break</span>;
00220                         }
00221                 }
00222 
00223                 <span class="keywordflow">if</span> (do_replace) {
00224                         <span class="keywordflow">if</span> (valsz &gt; cur-&gt;value_size) {
00225                                 cur-&gt;value = (<span class="keywordtype">char</span> *) realloc(cur-&gt;value, valsz);
00226                                 <span class="keywordflow">if</span> (!cur-&gt;value)
00227                                         <span class="keywordflow">return</span> FAILURE;
00228                         }
00229 
00230                         _bytes += (valsz - cur-&gt;value_size);
00231 
00232                         Memory::memCopy(cur-&gt;value, val, valsz);
00233                         cur-&gt;value_size = valsz;
00234                 } <span class="keywordflow">else</span> {
00235                         cur-&gt;key = (<span class="keywordtype">char</span> *) malloc(keysz);
00236                         <span class="keywordflow">if</span> (!cur-&gt;key)
00237                                 <span class="keywordflow">return</span> FAILURE;
00238 
00239                         Memory::memCopy(cur-&gt;key, key, keysz);
00240                         cur-&gt;key_size = keysz;
00241 
00242                         _bytes += keysz;
00243 
00244                         cur-&gt;value = (<span class="keywordtype">char</span> *) malloc(valsz);
00245                         <span class="keywordflow">if</span> (!cur-&gt;value) {
00246                                 free(cur-&gt;key);
00247                                 <span class="keywordflow">return</span> FAILURE;
00248                         }
00249 
00250                         Memory::memCopy(cur-&gt;value, val, valsz);
00251                         cur-&gt;value_size = valsz;
00252 
00253                         _bytes += valsz;
00254 
00255                         cur-&gt;empty = <span class="keyword">false</span>;
00256                         cur-&gt;next = NULL;
00257 
00258                         _elem_count++;
00259                 }
00260 
00261                 <span class="keywordflow">return</span> SUCCESS;
00262         }
00263 
<a name="l00264"></a><a class="code" href="classu_stream_lib_1_1_hash.html#a13">00264</a>         <a class="code" href="namespaceu_stream_lib.html#a244">int32</a> Hash::pput(<span class="keywordtype">char</span>* key, uint32 keysz, <span class="keywordtype">char</span>* val, <span class="keywordtype">bool</span> replace)
00265         {
00266                 <span class="keyword">struct </span>hash_elem_t* cur = NULL;
00267                 <span class="keyword">struct </span>hash_elem_t* pre = NULL;
00268                 <a class="code" href="namespaceu_stream_lib.html#a243">uint32</a> code = 0, do_replace = 0;
00269 
00270                 <span class="comment">/* compute hash code */</span>
00271                 <span class="keywordflow">if</span> (!_size)
00272                         <span class="keywordflow">return</span> FAILURE;
00273                 code = <a class="code" href="classu_stream_lib_1_1_hash.html#a3">hashCode</a>(key, keysz, _size);
00274 
00275                 <span class="comment">/* no collision detected */</span>
00276                 <span class="keywordflow">if</span> (_hte[code].empty) {
00277                         _hte[code].key = (<span class="keywordtype">char</span> *) malloc(keysz);
00278                         <span class="keywordflow">if</span> (!_hte[code].key)
00279                                 <span class="keywordflow">return</span> FAILURE;
00280 
00281                         Memory::memCopy(_hte[code].key, key, keysz);
00282                         _hte[code].key_size = keysz;
00283 
00284                         _bytes += keysz;
00285 
00286                         _hte[code].value = NULL;
00287                         _hte[code].value_size = 0;
00288                         _hte[code].pvalue = val;
00289                         _hte[code].empty = <span class="keyword">false</span>;
00290 
00291                         _elem_count++;
00292                         <span class="keywordflow">return</span> SUCCESS;
00293                 }
00294 
00295                 <span class="comment">/* collision detected */</span>
00296                 cur = &amp;(_hte[code]);
00297 
00298                 <span class="comment">/* get statistics on collisions */</span>
00299                 <span class="keywordflow">if</span> (!replace)
00300                         cur-&gt;hit_count++;
00301 
00302                 <span class="comment">/* chain scanning */</span>
00303                 <span class="keywordflow">while</span> (!cur-&gt;empty) {
00304                         <span class="comment">/* check for key duplicates */</span>
00305                         <span class="keywordflow">if</span> (cur-&gt;key_size == keysz) {
00306                                 <span class="keywordflow">if</span> (!<a class="code" href="classu_stream_lib_1_1_hash.html#a4">compare</a>(cur-&gt;key, key, keysz)) {
00307                                         <span class="keywordflow">if</span> (replace) {
00308                                                 do_replace = 1; <span class="keywordflow">break</span>;
00309                                         } <span class="keywordflow">else</span>
00310                                                 <span class="keywordflow">return</span> KEY_EXISTS;
00311                                 }
00312                         }
00313 
00314                         <span class="comment">// DEBUG</span>
00315                         <a class="code" href="typedefs_8hpp.html#a14">UOSUTIL_DOUT</a>((<span class="stringliteral">"Hash::pput(%s [%u]): collision, code = %u, hit = %u\n"</span>,
00316                                 key, keysz, code, cur-&gt;hit_count));
00317 
00318                         <span class="comment">/* update pointers */</span>
00319                         pre = cur;
00320                         cur = cur-&gt;next;
00321 
00322                         <span class="keywordflow">if</span> (cur == NULL) {
00323                                 cur = (<span class="keyword">struct </span>hash_elem_t *)
00324                                         malloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> hash_elem_t));
00325                                 <span class="keywordflow">if</span> (!cur)
00326                                         <span class="keywordflow">return</span> FAILURE;
00327 
00328                                 memset(cur, 0, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> hash_elem_t));
00329                                 _bytes += <span class="keyword">sizeof</span>(<span class="keyword">struct </span>hash_elem_t);
00330 
00331                                 cur-&gt;empty = <span class="keyword">true</span>;
00332                                 pre-&gt;next = cur;
00333 
00334                                 <span class="keywordflow">break</span>;
00335                         }
00336                 }
00337 
00338                 <span class="keywordflow">if</span> (do_replace) {
00339                         cur-&gt;pvalue = val;
00340                 } <span class="keywordflow">else</span> {
00341                         cur-&gt;key = (<span class="keywordtype">char</span> *) malloc(keysz);
00342                         <span class="keywordflow">if</span> (!cur-&gt;key)
00343                                 <span class="keywordflow">return</span> FAILURE;
00344 
00345                         Memory::memCopy(cur-&gt;key, key, keysz);
00346                         cur-&gt;key_size = keysz;
00347 
00348                         _bytes += keysz;
00349 
00350                         cur-&gt;value = NULL;
00351                         cur-&gt;value_size = 0;
00352                         cur-&gt;pvalue = val;
00353                         cur-&gt;empty = <span class="keyword">false</span>;
00354                         cur-&gt;next = NULL;
00355 
00356                         _elem_count++;
00357                 }
00358 
00359                 <span class="keywordflow">return</span> SUCCESS;
00360         }
00361 
<a name="l00362"></a><a class="code" href="classu_stream_lib_1_1_hash.html#a8">00362</a>         <span class="keywordtype">char</span>* Hash::get(<span class="keywordtype">char</span>* key, uint32 key_size)
00363         {
00364                 <span class="keyword">struct </span>hash_elem_t* cur = NULL;
00365                 <a class="code" href="namespaceu_stream_lib.html#a243">uint32</a> code = 0, depth = 0;
00366 
00367                 <span class="keywordflow">if</span> (!_size)
00368                         <span class="keywordflow">return</span> NULL;
00369                 code = <a class="code" href="classu_stream_lib_1_1_hash.html#a3">hashCode</a>(key, key_size, _size);
00370 
00371                 <span class="comment">/* direct access */</span>
00372                 <span class="keywordflow">if</span> (_hte[code].key_size == key_size) {
00373                         <span class="keywordflow">if</span> (!<a class="code" href="classu_stream_lib_1_1_hash.html#a4">compare</a>(_hte[code].key, key, key_size)) {
00374                                 <span class="keywordflow">if</span> (_hte[code].value)
00375                                         <span class="keywordflow">return</span> _hte[code].value;
00376                                 <span class="keywordflow">else</span>
00377                                         <span class="keywordflow">return</span> _hte[code].pvalue;
00378                         }
00379                 }
00380 
00381                 <span class="comment">/* chain scanning */</span>
00382                 cur = &amp;(_hte[code]);
00383 
00384                 <span class="keywordflow">while</span> (cur-&gt;next) {
00385                         cur = cur-&gt;next;
00386 
00387                         <span class="keywordflow">if</span> (cur-&gt;key_size == key_size) {
00388                                 <span class="keywordflow">if</span> (!<a class="code" href="classu_stream_lib_1_1_hash.html#a4">compare</a>(cur-&gt;key, key, key_size)) {
00389                                         <span class="keywordflow">if</span> (cur-&gt;value) {
00390                                                 <a class="code" href="typedefs_8hpp.html#a14">UOSUTIL_DOUT</a>((<span class="stringliteral">"Hash::get(%s [%u]): depth = %u\n"</span>, key,
00391                                                         key_size, depth));
00392                                                 <span class="keywordflow">return</span> cur-&gt;value;
00393                                         } <span class="keywordflow">else</span> {
00394                                                 <a class="code" href="typedefs_8hpp.html#a14">UOSUTIL_DOUT</a>((<span class="stringliteral">"Hash::get(%s [%u]): depth = %u\n"</span>, key,
00395                                                         key_size, depth));
00396                                                 <span class="keywordflow">return</span> cur-&gt;pvalue;
00397                                         }
00398                                 }
00399                         }
00400 
00401                         depth += 1;
00402                 }
00403 
00404                 <span class="comment">/* key not found */</span>
00405                 <span class="keywordflow">return</span> NULL;
00406         }
00407 
<a name="l00408"></a><a class="code" href="classu_stream_lib_1_1_hash.html#a9">00408</a>         <span class="keywordtype">char</span>* Hash::get(<span class="keywordtype">char</span>* key, uint32 key_size, uint32* valsz)
00409         {
00410                 <span class="keyword">struct </span>hash_elem_t* cur = NULL;
00411                 <a class="code" href="namespaceu_stream_lib.html#a243">uint32</a> code = 0, depth = 0;
00412 
00413                 <span class="keywordflow">if</span> (!_size)
00414                         <span class="keywordflow">return</span> NULL;
00415                 code = <a class="code" href="classu_stream_lib_1_1_hash.html#a3">hashCode</a>(key, key_size, _size);
00416 
00417                 <span class="comment">/* direct access */</span>
00418                 <span class="keywordflow">if</span> (_hte[code].key_size == key_size) {
00419                         <span class="keywordflow">if</span> (!<a class="code" href="classu_stream_lib_1_1_hash.html#a4">compare</a>(_hte[code].key, key, key_size)) {
00420                                 *valsz = _hte[code].value_size;
00421                                 <span class="keywordflow">if</span> (_hte[code].value)
00422                                         <span class="keywordflow">return</span> _hte[code].value;
00423                                 <span class="keywordflow">else</span>
00424                                         <span class="keywordflow">return</span> _hte[code].pvalue;
00425                         }
00426                 }
00427 
00428                 <span class="comment">/* chain scanning */</span>
00429                 cur = &amp;(_hte[code]);
00430 
00431                 <span class="keywordflow">while</span> (cur-&gt;next) {
00432                         cur = cur-&gt;next;
00433 
00434                         <span class="keywordflow">if</span> (cur-&gt;key_size == key_size) {
00435                                 <span class="keywordflow">if</span> (!<a class="code" href="classu_stream_lib_1_1_hash.html#a4">compare</a>(cur-&gt;key, key, key_size)) {
00436                                         *valsz = cur-&gt;value_size;
00437 
00438                                         <span class="keywordflow">if</span> (cur-&gt;value) {
00439                                                 <a class="code" href="typedefs_8hpp.html#a14">UOSUTIL_DOUT</a>((<span class="stringliteral">"Hash::get(%s [%u]): depth = %u\n"</span>, key,
00440                                                         key_size, depth));
00441                                                 <span class="keywordflow">return</span> cur-&gt;value;
00442                                         } <span class="keywordflow">else</span> {
00443                                                 <a class="code" href="typedefs_8hpp.html#a14">UOSUTIL_DOUT</a>((<span class="stringliteral">"Hash::get(%s [%u]): depth = %u\n"</span>, key,
00444                                                         key_size, depth));
00445                                                 <span class="keywordflow">return</span> cur-&gt;pvalue;
00446                                         }
00447                                 }
00448                         }
00449 
00450                         depth += 1;
00451                 }
00452 
00453                 <span class="comment">/* key not found */</span>
00454                 *valsz = 0;
00455                 <span class="keywordflow">return</span> NULL;
00456         }
00457 
<a name="l00458"></a><a class="code" href="classu_stream_lib_1_1_hash.html#a17">00458</a>         <a class="code" href="namespaceu_stream_lib.html#a244">int32</a> Hash::del(<span class="keywordtype">char</span>* key, uint32 key_size)
00459         {
00460                 <span class="keyword">struct </span>hash_elem_t* cur = NULL;
00461                 <span class="keyword">struct </span>hash_elem_t* base = NULL;
00462                 <a class="code" href="namespaceu_stream_lib.html#a243">uint32</a> code = 0;
00463 
00464                 <span class="keywordflow">if</span> (!_size)
00465                         <span class="keywordflow">return</span> FAILURE;
00466                 code = <a class="code" href="classu_stream_lib_1_1_hash.html#a3">hashCode</a>(key, key_size, _size);
00467 
00468                 <span class="comment">/* direct access */</span>
00469                 <span class="keywordflow">if</span> (_hte[code].key_size == key_size) {
00470                         <span class="keywordflow">if</span> (!<a class="code" href="classu_stream_lib_1_1_hash.html#a4">compare</a>(_hte[code].key, key, key_size)) {
00471                                 _htefree(&amp;_hte[code]);
00472                                 _elem_count--;
00473                                 <span class="keywordflow">return</span> SUCCESS;
00474                         }
00475                 }
00476 
00477                 <span class="comment">/* chain scanning */</span>
00478                 base = &amp;(_hte[code]);
00479                 cur = base;
00480 
00481                 <span class="keywordflow">while</span> (cur-&gt;next) {
00482                         cur = cur-&gt;next;
00483                         <span class="keywordflow">if</span> (cur-&gt;key_size == key_size) {
00484                                 <span class="keywordflow">if</span> (!<a class="code" href="classu_stream_lib_1_1_hash.html#a4">compare</a>(cur-&gt;key, key, key_size)) {
00485                                         _htefree(cur);
00486 
00487                                         _elem_count -= 1;
00488                                         base-&gt;hit_count -= 1;
00489 
00490                                         <span class="keywordflow">return</span> SUCCESS;
00491                                 }
00492                         }
00493                 }
00494 
00495                 <span class="comment">/* key not found */</span>
00496                 <span class="keywordflow">return</span> FAILURE;
00497         }
00498 
<a name="l00499"></a><a class="code" href="classu_stream_lib_1_1_hash.html#a19">00499</a>         <a class="code" href="classu_stream_lib_1_1_enumeration.html">Enumeration</a>* Hash::keys(<span class="keywordtype">void</span>)
00500         {
00501                 <span class="keyword">struct </span>hash_elem_t* cur;
00502                 <span class="keyword">struct </span>hash_elem_t* base;
00503                 <a class="code" href="namespaceu_stream_lib.html#a243">uint32</a> i;
00504 
00505                 _enKeys.<a class="code" href="classu_stream_lib_1_1_enumeration.html#a7">clear</a>();
00506 
00507                 <span class="keywordflow">for</span> (i = 0; i &lt; _size; i++) {
00508                         base = &amp;(_hte[i]);
00509                         cur = base;
00510 
00511                         <span class="keywordflow">if</span> (!cur-&gt;empty) {
00512                                 _enKeys.<a class="code" href="classu_stream_lib_1_1_enumeration.html#a10">addElement</a>(base-&gt;key, base-&gt;key_size);
00513                         }
00514 
00515                         <span class="keywordflow">while</span> (cur-&gt;next != NULL) {
00516                                 cur = cur-&gt;next;
00517                                 <span class="keywordflow">if</span> (!cur-&gt;empty) {
00518                                         _enKeys.<a class="code" href="classu_stream_lib_1_1_enumeration.html#a10">addElement</a>(cur-&gt;key, cur-&gt;key_size);
00519                                 }
00520                         }
00521                 }
00522 
00523                 _enKeys.<a class="code" href="classu_stream_lib_1_1_enumeration.html#a6">rewind</a>();
00524 
00525                 <span class="comment">// ok</span>
00526                 <span class="keywordflow">return</span> &amp;_enKeys;
00527         }
00528 
<a name="l00529"></a><a class="code" href="classu_stream_lib_1_1_hash.html#a20">00529</a>         <a class="code" href="classu_stream_lib_1_1_enumeration.html">Enumeration</a>* Hash::values(<span class="keywordtype">void</span>)
00530         {
00531                 <span class="keyword">struct </span>hash_elem_t* cur;
00532                 <span class="keyword">struct </span>hash_elem_t* base;
00533                 <a class="code" href="namespaceu_stream_lib.html#a243">uint32</a> i;
00534 
00535                 _enValues.<a class="code" href="classu_stream_lib_1_1_enumeration.html#a7">clear</a>();
00536 
00537                 <span class="keywordflow">for</span> (i = 0; i &lt; _size; i++) {
00538                         base = &amp;(_hte[i]);
00539                         cur = base;
00540 
00541                         <span class="keywordflow">if</span> (!cur-&gt;empty) {
00542                                 <span class="keywordflow">if</span> (base-&gt;value)
00543                                         _enValues.<a class="code" href="classu_stream_lib_1_1_enumeration.html#a10">addElement</a>(base-&gt;value, base-&gt;value_size);
00544                                 <span class="keywordflow">else</span>
00545                                         _enValues.<a class="code" href="classu_stream_lib_1_1_enumeration.html#a10">addElement</a>(base-&gt;pvalue, base-&gt;value_size);
00546                         }
00547 
00548                         <span class="keywordflow">while</span> (cur-&gt;next != NULL) {
00549                                 cur = cur-&gt;next;
00550                                 <span class="keywordflow">if</span> (!cur-&gt;empty) {
00551                                         <span class="keywordflow">if</span> (cur-&gt;value)
00552                                                 _enValues.<a class="code" href="classu_stream_lib_1_1_enumeration.html#a10">addElement</a>(cur-&gt;value, cur-&gt;value_size);
00553                                         <span class="keywordflow">else</span>
00554                                                 _enValues.<a class="code" href="classu_stream_lib_1_1_enumeration.html#a10">addElement</a>(cur-&gt;pvalue, cur-&gt;value_size);
00555                                 }
00556                         }
00557                 }
00558 
00559                 _enValues.<a class="code" href="classu_stream_lib_1_1_enumeration.html#a6">rewind</a>();
00560 
00561                 <span class="comment">// ok</span>
00562                 <span class="keywordflow">return</span> &amp;_enValues;
00563         }
00564 
<a name="l00565"></a><a class="code" href="classu_stream_lib_1_1_hash.html#a23">00565</a>         <span class="keywordtype">void</span> Hash::clear(<span class="keywordtype">void</span>)
00566         {
00567                 <a class="code" href="classu_stream_lib_1_1_enumeration.html">Enumeration</a>* en = <a class="code" href="classu_stream_lib_1_1_hash.html#a19">keys</a>();
00568                 <span class="keywordflow">while</span> (en-&gt;<a class="code" href="classu_stream_lib_1_1_enumeration.html#a3">hasMoreElements</a>()) {
00569                         <span class="keywordtype">char</span>* key = (<span class="keywordtype">char</span>*) en-&gt;<a class="code" href="classu_stream_lib_1_1_enumeration.html#a4">nextElement</a>();
00570                         <a class="code" href="typedefs_8hpp.html#a14">UOSUTIL_DOUT</a>((<span class="stringliteral">"Hash::clear(): deleting key = \"%s\"\n"</span>, key));
00571 
00572                         <a class="code" href="classu_stream_lib_1_1_hash.html#a17">del</a>(key);
00573                 }
00574         }
00575 
<a name="l00576"></a><a class="code" href="classu_stream_lib_1_1_hash.html#a5">00576</a>         <span class="keywordtype">void</span> Hash::statistics(<span class="keywordtype">void</span>)
00577         {
00578                 <a class="code" href="namespaceu_stream_lib.html#a243">uint32</a> i;
00579 
00580                 printf(<span class="stringliteral">"Hash::statistics: TOTAL %u\n"</span>, _elem_count);
00581                 printf(<span class="stringliteral">"Hash::statistics: TOTAL BYTES %u\n"</span>, _bytes);
00582                 <span class="keywordflow">for</span> (i = 0; i &lt; _size; i++)
00583                         printf(<span class="stringliteral">"%u %u\n"</span>, i, _hte[i].hit_count);
00584         }
00585 
<a name="l00586"></a><a class="code" href="classu_stream_lib_1_1_hash.html#a22">00586</a>         <a class="code" href="namespaceu_stream_lib.html#a244">int32</a> Hash::loadKV(<span class="keywordtype">char</span>* filename)
00587         {
00588                 FILE* fp = NULL;
00589 
00590                 <span class="keywordtype">char</span> line[4096];
00591                 <span class="keywordtype">char</span>* line_ptr = NULL, * end_ptr = NULL;
00592                 <span class="keywordtype">char</span>* cur_ptr = NULL, * key = NULL, * val = NULL;
00593                 <a class="code" href="namespaceu_stream_lib.html#a244">int32</a> ret = 0, error = 0, line_count = 0;
00594 
00595                 <span class="comment">// open the specified file for reading</span>
00596                 fp = fopen(filename, <span class="stringliteral">"r"</span>);
00597                 <span class="keywordflow">if</span> (!fp) {
00598                         _dbErrorString.<a class="code" href="classu_stream_lib_1_1_data_buf.html#a20">xcopy</a>(<span class="stringliteral">"open error"</span>); <span class="keywordflow">return</span> FAILURE;
00599                 }
00600 
00601                 <span class="keywordflow">while</span> (1) {
00602                         <span class="comment">// count lines</span>
00603                         line_count++;
00604 
00605                         <span class="comment">// read one line</span>
00606                         ret = Utils::getDelim(line, 4096, <a class="code" href="typedefs_8hpp.html#a9">LF</a>, fp);
00607                         <span class="keywordflow">if</span> (ret &lt; 0)
00608                                 <span class="keywordflow">break</span>;
00609 
00610                         <span class="comment">// remove ending spaces and line terminators</span>
00611                         line_ptr = line;
00612                         end_ptr = &amp;line[ret - 1];
00613                         <span class="keywordflow">while</span> (end_ptr &gt;=
00614                                 line_ptr &amp;&amp;
00615                                 (*end_ptr == <span class="charliteral">' '</span> ||
00616                                 *end_ptr == <span class="charliteral">'\t'</span> ||
00617                                 *end_ptr == <a class="code" href="typedefs_8hpp.html#a9">LF</a> ||
00618                                 *end_ptr == CR)) {
00619                                 *(end_ptr--) = <span class="charliteral">'\0'</span>;
00620                         }
00621 
00622                         <span class="comment">// remove trailing spaces</span>
00623                         <span class="keywordflow">while</span> (*line_ptr != <span class="charliteral">'\0'</span> &amp;&amp;
00624                                 (*line_ptr == <span class="charliteral">' '</span> || *line_ptr == <span class="charliteral">'\t'</span>))
00625                                 line_ptr++;
00626 
00627                         <span class="comment">// ignore empty lines and comments</span>
00628                         <span class="keywordflow">if</span> (*line_ptr == <span class="charliteral">'\0'</span> || *line_ptr == <span class="charliteral">'#'</span>)
00629                                 <span class="keywordflow">continue</span>;
00630 
00631                         <span class="comment">// do tokenizing</span>
00632                         cur_ptr = line_ptr;
00633 
00634                         key = Utils::getToken(&amp;cur_ptr, <span class="stringliteral">"="</span>);
00635                         <span class="keywordflow">if</span> (key == NULL)
00636                                 <span class="keywordflow">continue</span>;
00637 
00638                         val = cur_ptr;
00639                         <span class="keywordflow">if</span> (val == NULL)
00640                                 val = <span class="stringliteral">""</span>;
00641 
00642                         <span class="comment">// do trimming of key and val</span>
00643                         <span class="keywordflow">while</span> (*val != <span class="charliteral">'\0'</span> &amp;&amp; (*val == <span class="charliteral">' '</span> || *val == <span class="charliteral">'\t'</span>))
00644                                 val++;
00645 
00646                         ret = <a class="code" href="classu_stream_lib_1_1_hash.html#a12">put</a>(key, val, (<a class="code" href="namespaceu_stream_lib.html#a243">uint32</a>) strlen(val) + 1);
00647                         <span class="keywordflow">if</span> (ret == FAILURE) {
00648                                 error = 2; <span class="keywordflow">break</span>;
00649                         }
00650                 }
00651 
00652                 <span class="comment">// close the file</span>
00653                 fclose(fp);
00654 
00655                 <span class="comment">// detect error condition</span>
00656                 <span class="keywordflow">if</span> (error == 2) {
00657                         _dbErrorString.<a class="code" href="classu_stream_lib_1_1_data_buf.html#a20">xcopy</a>(<span class="stringliteral">"out of memory"</span>); <span class="keywordflow">return</span> FAILURE;
00658                 }
00659 
00660                 <span class="comment">// everything ok</span>
00661                 <span class="keywordflow">return</span> SUCCESS;
00662         }
00663 
<a name="l00664"></a><a class="code" href="classu_stream_lib_1_1_hash.html#a21">00664</a>         <a class="code" href="namespaceu_stream_lib.html#a244">int32</a> Hash::saveKV(<span class="keywordtype">char</span>* filename)
00665         {
00666                 <a class="code" href="classu_stream_lib_1_1_enumeration.html">Enumeration</a>* ek = NULL;
00667                 FILE* fp = NULL;
00668 
00669                 <span class="keywordtype">char</span>* key = NULL, * val = NULL;
00670                 <a class="code" href="namespaceu_stream_lib.html#a244">int32</a> ret = 0, error = 0;
00671 
00672                 <span class="comment">// open the specified file for writing</span>
00673                 fp = fopen(filename, <span class="stringliteral">"w+"</span>);
00674                 <span class="keywordflow">if</span> (!fp) {
00675                         _dbErrorString.<a class="code" href="classu_stream_lib_1_1_data_buf.html#a20">xcopy</a>(<span class="stringliteral">"open error"</span>); <span class="keywordflow">return</span> FAILURE;
00676                 }
00677 
00678                 <span class="comment">// take all the keys</span>
00679                 ek = <a class="code" href="classu_stream_lib_1_1_hash.html#a19">keys</a>();
00680                 <span class="keywordflow">while</span> (ek-&gt;<a class="code" href="classu_stream_lib_1_1_enumeration.html#a3">hasMoreElements</a>()) {
00681                         key = (<span class="keywordtype">char</span> *) ek-&gt;<a class="code" href="classu_stream_lib_1_1_enumeration.html#a4">nextElement</a>();
00682 
00683                         val = (<span class="keywordtype">char</span> *) <a class="code" href="classu_stream_lib_1_1_hash.html#a8">get</a>(key);
00684                         <span class="keywordflow">if</span> (!val) {
00685                                 error = 1; <span class="keywordflow">break</span>;
00686                         }
00687 
00688                         ret = fprintf(fp, <span class="stringliteral">"%s=%s\n"</span>, key, val);
00689                         <span class="keywordflow">if</span> (ret &lt; 0) {
00690                                 error = 2; <span class="keywordflow">break</span>;
00691                         }
00692                 }
00693 
00694                 <span class="comment">// close the file</span>
00695                 fclose(fp);
00696 
00697                 <span class="comment">// detect error conditions</span>
00698                 <span class="keywordflow">if</span> (error == 1) {
00699                         _dbErrorString.<a class="code" href="classu_stream_lib_1_1_data_buf.html#a20">xcopy</a>(<span class="stringliteral">"null value"</span>); <span class="keywordflow">return</span> FAILURE;
00700                 }
00701                 <span class="keywordflow">if</span> (error == 2) {
00702                         _dbErrorString.<a class="code" href="classu_stream_lib_1_1_data_buf.html#a20">xcopy</a>(<span class="stringliteral">"write error"</span>); <span class="keywordflow">return</span> FAILURE;
00703                 }
00704 
00705                 <span class="comment">// everything ok</span>
00706                 <span class="keywordflow">return</span> SUCCESS;
00707         }
00708 
00709         <span class="keywordtype">void</span> Hash::_htefree(<span class="keyword">struct</span> hash_elem_t* hte)
00710         {
00711                 <span class="keywordflow">if</span> (hte-&gt;value)
00712                         free(hte-&gt;value);
00713                 <span class="keywordflow">if</span> (hte-&gt;key)
00714                         free(hte-&gt;key);
00715 
00716                 _bytes -= (hte-&gt;key_size + hte-&gt;value_size);
00717 
00718                 hte-&gt;key = NULL;
00719                 hte-&gt;value = NULL;
00720                 hte-&gt;pvalue = NULL;
00721                 hte-&gt;key_size = 0;
00722                 hte-&gt;value_size = 0;
00723                 hte-&gt;empty = <span class="keyword">true</span>;
00724                 hte-&gt;hit_count = 0;
00725         }
00726 }
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Thu Feb 9 19:03:31 2006 for uStream by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
