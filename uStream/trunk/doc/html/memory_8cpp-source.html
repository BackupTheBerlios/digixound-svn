<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>uStream: C:/ustream_streaming_architecture/uOsUtil/src/core/memory.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a></div>
<div class="nav">
<a class="el" href="dir_000000.html">ustream_streaming_architecture</a>&nbsp;/&nbsp;<a class="el" href="dir_000001.html">uOsUtil</a>&nbsp;/&nbsp;<a class="el" href="dir_000006.html">src</a>&nbsp;/&nbsp;<a class="el" href="dir_000007.html">core</a></div>
<h1>memory.cpp</h1><a href="memory_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment">  uSTREAM LIGHT-WEIGHT STREAMING ARCHITECTURE</span>
00003 <span class="comment">  Copyright (C) 2005 Luis Serrano (luis@kontrol-dj.com) </span>
00004 <span class="comment">  </span>
00005 <span class="comment">  Based on DANUBIO STREAMING ARCHITECTURE by Michele Iacobellis (m.iacobellis@nexotech.it)</span>
00006 <span class="comment">  </span>
00007 <span class="comment">  This program is free software; you can redistribute it and/or modify</span>
00008 <span class="comment">  it under the terms of the GNU General Public License as published by</span>
00009 <span class="comment">  the Free Software Foundation; either version 2 of the License, or</span>
00010 <span class="comment">  (at your option) any later version.</span>
00011 <span class="comment">  </span>
00012 <span class="comment">  This program is distributed in the hope that it will be useful,</span>
00013 <span class="comment">  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00014 <span class="comment">  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
00015 <span class="comment">  GNU General Public License for more details.</span>
00016 <span class="comment">  </span>
00017 <span class="comment">  You should have received a copy of the GNU General Public License</span>
00018 <span class="comment">  along with this program; if not, write to the Free Software</span>
00019 <span class="comment">  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
00020 <span class="comment">  </span>
00021 <span class="comment">*/</span>
00022 
00023 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00024 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00025 <span class="preprocessor">#include &lt;malloc.h&gt;</span>
00026 <span class="preprocessor">#include &lt;string.h&gt;</span>
00027 
00028 <span class="preprocessor">#include "<a class="code" href="memory_8hpp.html">memory.hpp</a>"</span>
00029 <span class="preprocessor">#include "<a class="code" href="timer_8hpp.html">timer.hpp</a>"</span>
00030 
00031 <span class="keyword">namespace </span>uStreamLib {
00032         <span class="keywordtype">void</span>* <a class="code" href="namespaceu_stream_lib.html#a249">sse_memcpy</a>(<span class="keywordtype">void</span>* to, <span class="keyword">const</span> <span class="keywordtype">void</span>* from, uint32 len);
00033         <span class="keywordtype">void</span>* <a class="code" href="namespaceu_stream_lib.html#a250">mmx_memcpy</a>(<span class="keywordtype">void</span>* to, <span class="keyword">const</span> <span class="keywordtype">void</span>* from, uint32 len);
00034         <span class="keywordtype">void</span>* <a class="code" href="namespaceu_stream_lib.html#a251">mmx2_memcpy</a>(<span class="keywordtype">void</span>* to, <span class="keyword">const</span> <span class="keywordtype">void</span>* from, uint32 len);
00035         <span class="keywordtype">void</span>* <a class="code" href="namespaceu_stream_lib.html#a252">linux_kernel_memcpy</a>(<span class="keywordtype">void</span>* to, <span class="keyword">const</span> <span class="keywordtype">void</span>* from, uint32 len);
00036 
00037         <span class="comment">/*</span>
00038 <span class="comment">         * Implementation.</span>
00039 <span class="comment">         */</span>
00040         Memory::MemFunc Memory::_bestFuncSmall = memcpy;
00041         Memory::MemFunc Memory::_bestFunc1M = memcpy;
00042         Memory::MemFunc Memory::_bestFunc2M = memcpy;
00043 
00044         <span class="keywordtype">char</span> Memory::_bestFuncName[_MEMORY_FNAME_SIZE];
00045 
<a name="l00046"></a><a class="code" href="classu_stream_lib_1_1_memory.html#e1">00046</a>         <span class="keywordtype">void</span> Memory::benchmark(uint32 block_size, uint32 i_count)
00047         {
00048                 <span class="keywordtype">char</span>* buffer1 = NULL, * buffer2 = NULL;
00049                 <a class="code" href="namespaceu_stream_lib.html#a243">uint32</a> i = 0, j = 0;
00050 
00051                 <span class="keyword">struct </span>memcopy_desc {
00052                         Memory::MemFunc copy_func;
00053                         <span class="keywordtype">char</span>* name;
00054                         <span class="keywordtype">double</span> copy_time;
00055                 }
00056                 md[] = {
00057                          {
00058                                 memcpy,                          <span class="stringliteral">"memcpy"</span>, 0.0
00059                         },
00060 <span class="preprocessor">#if defined(ARCH_X86) &amp;&amp; defined(DNX_LINUX_API) &amp;&amp; defined(DNX_WIN32_API)</span>
00061 <span class="preprocessor"></span>                         {
00062                                 sse_memcpy,              <span class="stringliteral">"sse_memcpy"</span>, 0.0
00063                         }, {
00064                                 mmx_memcpy,              <span class="stringliteral">"mmx_memcpy"</span>, 0.0
00065                         }, {
00066                                 mmx2_memcpy,             <span class="stringliteral">"mmx2_memcpy"</span>, 0.0
00067                         }, {
00068                                 linux_kernel_memcpy, <span class="stringliteral">"linux_kernel_memcpy"</span>, 0.0
00069                         }
00070 <span class="preprocessor">#endif</span>
00071 <span class="preprocessor"></span>                };
00072 
00073                 <a class="code" href="classu_stream_lib_1_1_timer.html">Timer</a> t;
00074                 <a class="code" href="structu_stream_lib_1_1timedesc__t.html">TimeDesc</a> td;
00075 
00076                 <span class="keywordtype">double</span> copy_time = 0;
00077                 <span class="keywordtype">double</span> best_time = 1.0e9;
00078 
00079                 <span class="comment">/*</span>
00080 <span class="comment">                 * Let's test all functions.</span>
00081 <span class="comment">                 */</span>
00082 
00083                 <span class="keywordflow">for</span> (j = 0; j &lt; <span class="keyword">sizeof</span>(md) / <span class="keyword">sizeof</span>(memcopy_desc); j++) {
00084                         <span class="comment">/*</span>
00085 <span class="comment">                         * Allocation of buffers.</span>
00086 <span class="comment">                         */</span>
00087                         buffer1 = (<span class="keywordtype">char</span> *) malloc(block_size);
00088                         <span class="keywordflow">if</span> (!buffer1) {
00089                                 printf(<span class="stringliteral">"Out of memory.\n"</span>); <span class="keywordflow">return</span>;
00090                         }
00091                         buffer2 = (<span class="keywordtype">char</span> *) malloc(block_size);
00092                         <span class="keywordflow">if</span> (!buffer2) {
00093                                 printf(<span class="stringliteral">"Out of memory.\n"</span>); <span class="keywordflow">return</span>;
00094                         }
00095 
00096                         t.<a class="code" href="classu_stream_lib_1_1_timer.html#a3">start</a>();
00097 
00098                         <span class="keywordflow">for</span> (i = 0; i &lt; i_count; i++) {
00099                                 md[j].copy_func(buffer1, buffer2, block_size);
00100                         }
00101 
00102                         t.<a class="code" href="classu_stream_lib_1_1_timer.html#a4">stop</a>(&amp;td);
00103                         copy_time = td.<a class="code" href="structu_stream_lib_1_1timedesc__t.html#o4">usec</a> +
00104                                 td.<a class="code" href="structu_stream_lib_1_1timedesc__t.html#o3">msec</a> * 1e3 +
00105                                 td.<a class="code" href="structu_stream_lib_1_1timedesc__t.html#o2">sec</a> * 1e6 +
00106                                 td.<a class="code" href="structu_stream_lib_1_1timedesc__t.html#o1">min</a> * 60e6;
00107                         md[j].copy_time = copy_time;
00108 
00109                         <span class="comment">/*</span>
00110 <span class="comment">                         * Deallocation of buffers.</span>
00111 <span class="comment">                         */</span>
00112                         free(buffer1);
00113                         free(buffer2);
00114                 }
00115 
00116                 <span class="comment">/*</span>
00117 <span class="comment">                 * Detect best time.</span>
00118 <span class="comment">                 */</span>
00119                 <span class="keywordflow">for</span> (j = 0; j &lt; <span class="keyword">sizeof</span>(md) / <span class="keyword">sizeof</span>(memcopy_desc); j++) {
00120                         <span class="keywordflow">if</span> (md[j].copy_time &lt; best_time) {
00121                                 best_time = md[j].copy_time;
00122 
00123                                 <span class="keywordflow">if</span> (block_size &lt;= 1000000) {
00124                                         _bestFuncSmall = md[j].copy_func;
00125                                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (block_size &gt; 1000000 &amp;&amp; block_size &lt; 2000000) {
00126                                         _bestFunc1M = md[j].copy_func;
00127                                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (block_size &gt;= 2000000) {
00128                                         _bestFunc2M = md[j].copy_func;
00129                                 }
00130 
00131                                 snprintf(_bestFuncName, <span class="keyword">sizeof</span>(_bestFuncName), <span class="stringliteral">"%s"</span>,
00132                                         md[j].name);
00133                         }
00134                 }
00135         }
00136 
00137         <span class="comment">/*</span>
00138 <span class="comment">         * These are the MMX/MMX2/SSE optimized versions of memcpy</span>
00139 <span class="comment">         *</span>
00140 <span class="comment">         * This code was adapted from Linux Kernel sources by Nick Kurshev to</span>
00141 <span class="comment">         * the mplayer program. (http://mplayer.sourceforge.net)</span>
00142 <span class="comment">         *</span>
00143 <span class="comment">         * Miguel Freitas split the #ifdefs into several specialized functions that</span>
00144 <span class="comment">         * are benchmarked at runtime by xine. Some original comments from Nick</span>
00145 <span class="comment">         * have been preserved documenting some MMX/SSE oddities.</span>
00146 <span class="comment">         * Also added kernel memcpy function that seems faster than glibc one.</span>
00147 <span class="comment">         *</span>
00148 <span class="comment">         * Modified by Michele Iacobellis to make it usable into the DSASL and</span>
00149 <span class="comment">         * Danubio Library.</span>
00150 <span class="comment">         */</span>
00151 
00152          <span class="comment">/* </span>
00153 <span class="comment">          Original comments from mplayer (file: aclib.c)</span>
00154 <span class="comment">          This part of code was taken by me from Linux-2.4.3 and slightly modified</span>
00155 <span class="comment">          for MMX, MMX2, SSE instruction set. I have done it since linux uses page</span>
00156 <span class="comment">          aligned blocks but mplayer uses weakly ordered data and original sources</span>
00157 <span class="comment">          cannot speedup them. Only using PREFETCHNTA and MOVNTQ together have effect!</span>
00158 <span class="comment">          &gt;From IA-32 Intel Architecture Software Developer's Manual Volume 1,</span>
00159 <span class="comment">          Order Number 245470:</span>
00160 <span class="comment">          "10.4.6. Cacheability Control, Prefetch, and Memory Ordering Instructions"</span>
00161 <span class="comment">          Data referenced by a program can be temporal (data will be used again) or</span>
00162 <span class="comment">          non-temporal (data will be referenced once and not reused in the immediate</span>
00163 <span class="comment">          future). To make efficient use of the processor's caches, it is generally</span>
00164 <span class="comment">          desirable to cache temporal data and not cache non-temporal data. Overloading</span>
00165 <span class="comment">          the processor's caches with non-temporal data is sometimes referred to as</span>
00166 <span class="comment">          "polluting the caches".</span>
00167 <span class="comment">          The non-temporal data is written to memory with Write-Combining semantics.</span>
00168 <span class="comment">          The PREFETCHh instructions permits a program to load data into the processor</span>
00169 <span class="comment">          at a suggested cache level, so that it is closer to the processors load and</span>
00170 <span class="comment">          store unit when it is needed. If the data is already present in a level of</span>
00171 <span class="comment">          the cache hierarchy that is closer to the processor, the PREFETCHh instruction</span>
00172 <span class="comment">          will not result in any data movement.</span>
00173 <span class="comment">          But we should you PREFETCHNTA: Non-temporal data fetch data into location</span>
00174 <span class="comment">          close to the processor, minimizing cache pollution.</span>
00175 <span class="comment">          The MOVNTQ (store quadword using non-temporal hint) instruction stores</span>
00176 <span class="comment">          packed integer data from an MMX register to memory, using a non-temporal hint.</span>
00177 <span class="comment">          The MOVNTPS (store packed single-precision floating-point values using</span>
00178 <span class="comment">          non-temporal hint) instruction stores packed floating-point data from an</span>
00179 <span class="comment">          XMM register to memory, using a non-temporal hint.</span>
00180 <span class="comment">          The SFENCE (Store Fence) instruction controls write ordering by creating a</span>
00181 <span class="comment">          fence for memory store operations. This instruction guarantees that the</span>
00182 <span class="comment">          results of every store instruction that precedes the store fence in program</span>
00183 <span class="comment">          order is globally visible before any store instruction that follows the</span>
00184 <span class="comment">          fence. The  SFENCE instruction provides an efficient way of ensuring ordering</span>
00185 <span class="comment">          between procedures that produce weakly-ordered data and procedures that</span>
00186 <span class="comment">          consume that data.</span>
00187 <span class="comment">          If you have questions please contact with me:</span>
00188 <span class="comment">          Nick Kurshev: nickols_k@mail.ru.</span>
00189 <span class="comment">        */</span>
00190 
00191         <span class="comment">/*</span>
00192 <span class="comment">          mmx v.1 Note: Since we added alignment of destinition it speedups</span>
00193 <span class="comment">          of memory copying on PentMMX, Celeron-1 and P2 upto 12% versus</span>
00194 <span class="comment">          standard (non MMX-optimized) version.</span>
00195 <span class="comment">          Note: on K6-2+ it speedups memory copying upto 25% and</span>
00196 <span class="comment">          on K7 and P3 about 500% (5 times).</span>
00197 <span class="comment">        */</span>
00198 
00199         <span class="comment">/*</span>
00200 <span class="comment">          Additional notes on gcc assembly and processors: [MF]</span>
00201 <span class="comment">          prefetch is specific for AMD processors, the intel ones should be</span>
00202 <span class="comment">          prefetch0, prefetch1, prefetch2 which are not recognized by my gcc.</span>
00203 <span class="comment">          prefetchnta is supported both on athlon and pentium 3.</span>
00204 <span class="comment">          therefore i will take off prefetchnta instructions from the mmx1 version</span>
00205 <span class="comment">          to avoid problems on pentium mmx and k6-2.</span>
00206 <span class="comment">          quote of the day:</span>
00207 <span class="comment">          "Using prefetches efficiently is more of an art than a science"</span>
00208 <span class="comment">        */</span>
00209 
00210 
00211 <span class="preprocessor">#if defined(ARCH_X86) &amp;&amp; defined(DNX_LINUX_API) &amp;&amp; defined(DNX_WIN32_API)</span>
00212 <span class="preprocessor"></span>
00213         <span class="comment">/* for small memory blocks (&lt;256 bytes) this version is faster */</span>
00214 <span class="preprocessor">#define small_memcpy(to,from,n) {\</span>
00215 <span class="preprocessor">register unsigned long int dummy;\</span>
00216 <span class="preprocessor">__asm__ __volatile__(\</span>
00217 <span class="preprocessor">  "rep; movsb"\</span>
00218 <span class="preprocessor">  :"=&amp;D"(to), "=&amp;S"(from), "=&amp;c"(dummy)\</span>
00219 <span class="preprocessor">  :"0" (to), "1" (from),"2" (n)\</span>
00220 <span class="preprocessor">  : "memory");\</span>
00221 <span class="preprocessor">}</span>
00222 <span class="preprocessor"></span>
00223         <span class="comment">/* linux kernel __memcpy (from: /include/asm/string.h) */</span>
00224         <span class="keyword">static</span> __inline__ <span class="keywordtype">void</span>* __memcpy(<span class="keywordtype">void</span>* to, <span class="keyword">const</span> <span class="keywordtype">void</span>* from, uint32 n)
00225         {
00226                 <span class="keywordtype">int</span> d0, d1, d2;
00227 
00228                 <span class="keywordflow">if</span> (n &lt; 4) {
00229                         small_memcpy(to, from, n);
00230                 } <span class="keywordflow">else</span>
00231                         __asm__ __volatile__(<span class="stringliteral">"rep ; movsl\n\t"</span>
00232                                                                  <span class="stringliteral">"testb $2,%b4\n\t"</span>
00233                                                                  <span class="stringliteral">"je 1f\n\t"</span>
00234                                                                  <span class="stringliteral">"movsw\n"</span>
00235                                                                  <span class="stringliteral">"1:\ttestb $1,%b4\n\t"</span>
00236                                                                  <span class="stringliteral">"je 2f\n\t"</span>
00237                                                                  <span class="stringliteral">"movsb\n"</span>
00238                                                                  <span class="stringliteral">"2:"</span> :
00239                                 <span class="stringliteral">"=&amp;c"</span> (d0),
00240                                 <span class="stringliteral">"=&amp;D"</span> (d1), <span class="stringliteral">"=&amp;S"</span> (d2) :
00241                                 <span class="stringliteral">"0"</span> (n / 4), <span class="stringliteral">"q"</span> (n),
00242                                 <span class="stringliteral">"1"</span> ((<span class="keywordtype">long</span>) to), <span class="stringliteral">"2"</span> ((<span class="keywordtype">long</span>) from) :
00243                                 <span class="stringliteral">"memory"</span>);
00244 
00245                 <span class="keywordflow">return</span> (to);
00246         }
00247 
00248 <span class="preprocessor">#define SSE_MMREG_SIZE 16</span>
00249 <span class="preprocessor"></span><span class="preprocessor">#define MMX_MMREG_SIZE 8</span>
00250 <span class="preprocessor"></span>
00251 <span class="preprocessor">#define MMX1_MIN_LEN 0x800  </span><span class="comment">/* 2K blocks */</span>
00252 <span class="preprocessor">#define MIN_LEN 0x40  </span><span class="comment">/* 64-byte blocks */</span>
00253 
00254         <span class="comment">/* SSE note: i tried to move 128 bytes a time instead of 64 but it</span>
00255 <span class="comment">          didn't make any measureable difference. i'm using 64 for the sake of</span>
00256 <span class="comment">          simplicity. [MF] */</span>
00257         <span class="keywordtype">void</span>* <a class="code" href="namespaceu_stream_lib.html#a249">sse_memcpy</a>(<span class="keywordtype">void</span>* to, <span class="keyword">const</span> <span class="keywordtype">void</span>* from, uint32 len)
00258         {
00259                 <span class="keywordtype">void</span>* retval;
00260                 <a class="code" href="namespaceu_stream_lib.html#a243">uint32</a> i;
00261                 retval = to;
00262 
00263                 <span class="comment">/* PREFETCH has effect even for MOVSB instruction ;) */</span>
00264                 __asm__ __volatile__
00265                 (
00266                 <span class="stringliteral">"   prefetchnta (%0)\n"</span>
00267                 <span class="stringliteral">"   prefetchnta 32(%0)\n"</span>
00268                 <span class="stringliteral">"   prefetchnta 64(%0)\n"</span>
00269                 <span class="stringliteral">"   prefetchnta 96(%0)\n"</span>
00270                 <span class="stringliteral">"   prefetchnta 128(%0)\n"</span>
00271                 <span class="stringliteral">"   prefetchnta 160(%0)\n"</span>
00272                 <span class="stringliteral">"   prefetchnta 192(%0)\n"</span>
00273                 <span class="stringliteral">"   prefetchnta 224(%0)\n"</span>
00274                 <span class="stringliteral">"   prefetchnta 256(%0)\n"</span>
00275                 <span class="stringliteral">"   prefetchnta 288(%0)\n"</span> :
00276                                         :
00277                                         <span class="stringliteral">"r"</span> (from)
00278                 );
00279 
00280                 <span class="keywordflow">if</span> (len &gt;= MIN_LEN) {
00281                         <span class="keyword">register</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> delta;
00282                         <span class="comment">/* Align destinition to MMREG_SIZE -boundary */</span>
00283                         delta = ((<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> int) to) &amp; (SSE_MMREG_SIZE - 1);
00284                         <span class="keywordflow">if</span> (delta) {
00285                                 delta = SSE_MMREG_SIZE - delta;
00286                                 len -= delta;
00287                                 small_memcpy(to, from, delta);
00288                         }
00289                         i = len &gt;&gt; 6; <span class="comment">/* len/64 */</span>
00290                         len &amp;= 63;
00291                         <span class="keywordflow">if</span> (((<span class="keywordtype">unsigned</span> long) from) &amp; 15)
00292                                         <span class="comment">/* if SRC is misaligned */</span>
00293                                 <span class="keywordflow">for</span> (; i &gt; 0; i--) {
00294                                         __asm__ __volatile__ 
00295                                         (
00296                                         <span class="stringliteral">"prefetchnta 320(%0)\n"</span>
00297                                         <span class="stringliteral">"prefetchnta 352(%0)\n"</span>
00298                                         <span class="stringliteral">"movups (%0), %%xmm0\n"</span>
00299                                         <span class="stringliteral">"movups 16(%0), %%xmm1\n"</span>
00300                                         <span class="stringliteral">"movups 32(%0), %%xmm2\n"</span>
00301                                         <span class="stringliteral">"movups 48(%0), %%xmm3\n"</span>
00302                                         <span class="stringliteral">"movntps %%xmm0, (%1)\n"</span>
00303                                         <span class="stringliteral">"movntps %%xmm1, 16(%1)\n"</span>
00304                                         <span class="stringliteral">"movntps %%xmm2, 32(%1)\n"</span>
00305                                         <span class="stringliteral">"movntps %%xmm3, 48(%1)\n"</span>
00306                                         :: <span class="stringliteral">"r"</span> (from), <span class="stringliteral">"r"</span> (to) :
00307                                                                 <span class="stringliteral">"memory"</span>
00308                                         );
00309                                         ((<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *) from) += 64;
00310                                         ((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *) to) += 64;
00311                                 }
00312                         <span class="keywordflow">else</span> {
00313                                 <span class="comment">/*</span>
00314 <span class="comment">                                                  Only if SRC is aligned on 16-byte boundary.</span>
00315 <span class="comment">                                                  It allows to use movaps instead of movups, which required data</span>
00316 <span class="comment">                                                  to be aligned or a general-protection exception (#GP) is generated.</span>
00317 <span class="comment">                                                */</span>
00318                                 <span class="keywordflow">for</span> (; i &gt; 0; i--) {
00319                                         __asm__ __volatile__
00320                                         (
00321                                         <span class="stringliteral">"prefetchnta 320(%0)\n"</span>
00322                                         <span class="stringliteral">"prefetchnta 352(%0)\n"</span>
00323                                         <span class="stringliteral">"movaps (%0), %%xmm0\n"</span>
00324                                         <span class="stringliteral">"movaps 16(%0), %%xmm1\n"</span>
00325                                         <span class="stringliteral">"movaps 32(%0), %%xmm2\n"</span>
00326                                         <span class="stringliteral">"movaps 48(%0), %%xmm3\n"</span>
00327                                         <span class="stringliteral">"movntps %%xmm0, (%1)\n"</span>
00328                                         <span class="stringliteral">"movntps %%xmm1, 16(%1)\n"</span>
00329                                         <span class="stringliteral">"movntps %%xmm2, 32(%1)\n"</span>
00330                                         <span class="stringliteral">"movntps %%xmm3, 48(%1)\n"</span>
00331                                         :: <span class="stringliteral">"r"</span> (from), <span class="stringliteral">"r"</span> (to) :
00332                                                                 <span class="stringliteral">"memory"</span>
00333                                         );
00334                                         ((<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *) from) += 64;
00335                                         ((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *) to) += 64;
00336                                 }
00337                                 <span class="comment">/* since movntq is weakly-ordered, a "sfence"</span>
00338 <span class="comment">                                                * is needed to become ordered again. */</span>
00339                                 __asm__ __volatile__ (<span class="stringliteral">"sfence"</span>:::<span class="stringliteral">"memory"</span>);
00340                                 <span class="comment">/* enables to use FPU */</span>
00341                                 __asm__ __volatile__ (<span class="stringliteral">"emms"</span>:::<span class="stringliteral">"memory"</span>);
00342                         }
00343                 }
00344 
00345                 <span class="comment">/*</span>
00346 <span class="comment">                        *       Now do the tail of the block</span>
00347 <span class="comment">                        */</span>
00348                 <span class="keywordflow">if</span> (len)
00349                         __memcpy(to, from, len);
00350                 <span class="keywordflow">return</span> retval;
00351         }
00352 
00353         <span class="keywordtype">void</span>* <a class="code" href="namespaceu_stream_lib.html#a250">mmx_memcpy</a>(<span class="keywordtype">void</span>* to, <span class="keyword">const</span> <span class="keywordtype">void</span>* from, uint32 len)
00354         {
00355                 <span class="keywordtype">void</span>* retval;
00356                 <a class="code" href="namespaceu_stream_lib.html#a243">uint32</a> i;
00357                 retval = to;
00358 
00359                 <span class="keywordflow">if</span> (len &gt;= MMX1_MIN_LEN) {
00360                         <span class="keyword">register</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> delta;
00361                         <span class="comment">/* Align destinition to MMREG_SIZE -boundary */</span>
00362                         delta = ((<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> int) to) &amp; (MMX_MMREG_SIZE - 1);
00363                         <span class="keywordflow">if</span> (delta) {
00364                                 delta = MMX_MMREG_SIZE - delta;
00365                                 len -= delta;
00366                                 small_memcpy(to, from, delta);
00367                         }
00368                         i = len &gt;&gt; 6; <span class="comment">/* len/64 */</span>
00369                         len &amp;= 63;
00370                         <span class="keywordflow">for</span> (; i &gt; 0; i--) {
00371                                 __asm__ __volatile__
00372                                 (
00373                                 <span class="stringliteral">"movq (%0), %%mm0\n"</span>
00374                                 <span class="stringliteral">"movq 8(%0), %%mm1\n"</span>
00375                                 <span class="stringliteral">"movq 16(%0), %%mm2\n"</span>
00376                                 <span class="stringliteral">"movq 24(%0), %%mm3\n"</span>
00377                                 <span class="stringliteral">"movq 32(%0), %%mm4\n"</span>
00378                                 <span class="stringliteral">"movq 40(%0), %%mm5\n"</span>
00379                                 <span class="stringliteral">"movq 48(%0), %%mm6\n"</span>
00380                                 <span class="stringliteral">"movq 56(%0), %%mm7\n"</span>
00381                                 <span class="stringliteral">"movq %%mm0, (%1)\n"</span>
00382                                 <span class="stringliteral">"movq %%mm1, 8(%1)\n"</span>
00383                                 <span class="stringliteral">"movq %%mm2, 16(%1)\n"</span>
00384                                 <span class="stringliteral">"movq %%mm3, 24(%1)\n"</span>
00385                                 <span class="stringliteral">"movq %%mm4, 32(%1)\n"</span>
00386                                 <span class="stringliteral">"movq %%mm5, 40(%1)\n"</span>
00387                                 <span class="stringliteral">"movq %%mm6, 48(%1)\n"</span>
00388                                 <span class="stringliteral">"movq %%mm7, 56(%1)\n"</span>
00389                                 :: <span class="stringliteral">"r"</span> (from), <span class="stringliteral">"r"</span> (to) :
00390                                                         <span class="stringliteral">"memory"</span>
00391                                 );
00392                                 ((<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *) from) += 64;
00393                                 ((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *) to) += 64;
00394                         }
00395                         __asm__ __volatile__ (<span class="stringliteral">"emms"</span>:::<span class="stringliteral">"memory"</span>);
00396                 }
00397                 <span class="comment">/*</span>
00398 <span class="comment">                        *       Now do the tail of the block</span>
00399 <span class="comment">                        */</span>
00400                 <span class="keywordflow">if</span> (len)
00401                         __memcpy(to, from, len);
00402                 <span class="keywordflow">return</span> retval;
00403         }
00404 
00405         <span class="keywordtype">void</span>* <a class="code" href="namespaceu_stream_lib.html#a251">mmx2_memcpy</a>(<span class="keywordtype">void</span>* to, <span class="keyword">const</span> <span class="keywordtype">void</span>* from, uint32 len)
00406         {
00407                 <span class="keywordtype">void</span>* retval;
00408                 <a class="code" href="namespaceu_stream_lib.html#a243">uint32</a> i;
00409                 retval = to;
00410 
00411                 <span class="comment">/* PREFETCH has effect even for MOVSB instruction ;) */</span>
00412                 __asm__ __volatile__
00413                 (
00414                 <span class="stringliteral">"   prefetchnta (%0)\n"</span>
00415                 <span class="stringliteral">"   prefetchnta 32(%0)\n"</span>
00416                 <span class="stringliteral">"   prefetchnta 64(%0)\n"</span>
00417                 <span class="stringliteral">"   prefetchnta 96(%0)\n"</span>
00418                 <span class="stringliteral">"   prefetchnta 128(%0)\n"</span>
00419                 <span class="stringliteral">"   prefetchnta 160(%0)\n"</span>
00420                 <span class="stringliteral">"   prefetchnta 192(%0)\n"</span>
00421                 <span class="stringliteral">"   prefetchnta 224(%0)\n"</span>
00422                 <span class="stringliteral">"   prefetchnta 256(%0)\n"</span>
00423                 <span class="stringliteral">"   prefetchnta 288(%0)\n"</span> :
00424                                         :
00425                                         <span class="stringliteral">"r"</span> (from) 
00426                 );
00427 
00428                 <span class="keywordflow">if</span> (len &gt;= MIN_LEN) {
00429                         <span class="keyword">register</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> delta;
00430                         <span class="comment">/* Align destinition to MMREG_SIZE -boundary */</span>
00431                         delta = ((<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> int) to) &amp; (MMX_MMREG_SIZE - 1);
00432                         <span class="keywordflow">if</span> (delta) {
00433                                 delta = MMX_MMREG_SIZE - delta;
00434                                 len -= delta;
00435                                 small_memcpy(to, from, delta);
00436                         }
00437                         i = len &gt;&gt; 6; <span class="comment">/* len/64 */</span>
00438                         len &amp;= 63;
00439                         <span class="keywordflow">for</span> (; i &gt; 0; i--) {
00440                                 __asm__ __volatile__
00441                                 (
00442                                 <span class="stringliteral">"prefetchnta 320(%0)\n"</span>
00443                                 <span class="stringliteral">"prefetchnta 352(%0)\n"</span>
00444                                 <span class="stringliteral">"movq (%0), %%mm0\n"</span>
00445                                 <span class="stringliteral">"movq 8(%0), %%mm1\n"</span>
00446                                 <span class="stringliteral">"movq 16(%0), %%mm2\n"</span>
00447                                 <span class="stringliteral">"movq 24(%0), %%mm3\n"</span>
00448                                 <span class="stringliteral">"movq 32(%0), %%mm4\n"</span>
00449                                 <span class="stringliteral">"movq 40(%0), %%mm5\n"</span>
00450                                 <span class="stringliteral">"movq 48(%0), %%mm6\n"</span>
00451                                 <span class="stringliteral">"movq 56(%0), %%mm7\n"</span>
00452                                 <span class="stringliteral">"movntq %%mm0, (%1)\n"</span>
00453                                 <span class="stringliteral">"movntq %%mm1, 8(%1)\n"</span>
00454                                 <span class="stringliteral">"movntq %%mm2, 16(%1)\n"</span>
00455                                 <span class="stringliteral">"movntq %%mm3, 24(%1)\n"</span>
00456                                 <span class="stringliteral">"movntq %%mm4, 32(%1)\n"</span>
00457                                 <span class="stringliteral">"movntq %%mm5, 40(%1)\n"</span>
00458                                 <span class="stringliteral">"movntq %%mm6, 48(%1)\n"</span>
00459                                 <span class="stringliteral">"movntq %%mm7, 56(%1)\n"</span>
00460                                 :: <span class="stringliteral">"r"</span> (from), <span class="stringliteral">"r"</span> (to) :
00461                                                         <span class="stringliteral">"memory"</span>
00462                                 );
00463                                 ((<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *) from) += 64;
00464                                 ((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *) to) += 64;
00465                         }
00466                         <span class="comment">/* since movntq is weakly-ordered, a "sfence"</span>
00467 <span class="comment">                                          * is needed to become ordered again. */</span>
00468                         __asm__ __volatile__ (<span class="stringliteral">"sfence"</span>:::<span class="stringliteral">"memory"</span>);
00469                         __asm__ __volatile__ (<span class="stringliteral">"emms"</span>:::<span class="stringliteral">"memory"</span>);
00470                 }
00471                 <span class="comment">/*</span>
00472 <span class="comment">                        *       Now do the tail of the block</span>
00473 <span class="comment">                        */</span>
00474                 <span class="keywordflow">if</span> (len)
00475                         __memcpy(to, from, len);
00476                 <span class="keywordflow">return</span> retval;
00477         }
00478 
00479         <span class="keywordtype">void</span>* <a class="code" href="namespaceu_stream_lib.html#a252">linux_kernel_memcpy</a>(<span class="keywordtype">void</span>* to, <span class="keyword">const</span> <span class="keywordtype">void</span>* from, uint32 len)
00480         {
00481                 <span class="keywordflow">return</span> __memcpy(to, from, len);
00482         }
00483 <span class="preprocessor">#endif</span>
00484 <span class="preprocessor"></span>}
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Thu Feb 9 19:03:31 2006 for uStream by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
